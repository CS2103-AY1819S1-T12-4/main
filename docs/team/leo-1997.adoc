= Li Changrui - Project Portfolio
:site-section: AboutUs
:imagesDir: ../images
:stylesDir: ../stylesheets
:sectnums:

= PROJECT: SaveIt

---

== Overview

This document is to summarize and elaborate all my contributions to the project.
Our project, SaveIt, is a issue tracker application which was morphed from AddressBook4.

SaveIt dedicates to provide a platform for storing, managing and viewing their programming related issues during daily practice for the programmers. Its main features includes adding new issue and solution, managing existing issues as well as finding existing issues. It is especially designed for the user who prefers command line interface (CLI) as the all the commands requires command line input. It also preserved the benefits of a Graphical User Interface (GUI) at the same time. If you can type fast, SaveIt can help you search the same issue that save previously faster than traditional GUI apps.

The project is implemented for applying and showing the learning outcomes of CS2103T, and it is done by a group of five CS2103T students including myself.

== Summary of contributions
This section is to summarize and explain my contributions towards this project.

* *Major enhancement*: add the *solution filed to model structure along with enable adding solution or issue*
** What it does: It constitutes the basic model structure by adding new issue and new solution into SaveIt. This allows all the following features to be carried out in SaveIt.
** Justification: This feature improves the product significantly as a user can now add more issues and solutions to the application. This is the most important and fundamental function our application aims to achieve.
** Highlights: This enhancement involves not only model component but also GUI, storage components in the application and it requires a lot of effort to build it properly. The add command on the other hand needs to handle different request in different directories.

* *Minor enhancement*:
** Implement basic autosuggestion feature for find and findByTag command. https://github.com/CS2103-AY1819S1-T12-4/main/pull/107[#107]
** Refactor autosuggestion component. https://github.com/CS2103-AY1819S1-T12-4/main/pull/168[#168]
** Add retrieve command to copy the solution link to system clipboard. https://github.com/CS2103-AY1819S1-T12-4/main/pull/85[#85]
** Refactor the application from AddressBook Level 4 to SaveIt. https://github.com/CS2103-AY1819S1-T12-4/main/pull/4[#4] https://github.com/CS2103-AY1819S1-T12-4/main/pull/56[#56] https://github.com/CS2103-AY1819S1-T12-4/main/pull/68[#68]

* *Code contributed*: [https://nus-cs2103-ay1819s1.github.io/cs2103-dashboard/#=undefined&search=leo-1997[Functional code]]

* *Other contributions*:

** Project management:
*** Manage milestones and checked issue status on GitHub
** Improve JUnit tests:
*** Rewrite exiting failing tests and add new tests:
https://github.com/CS2103-AY1819S1-T12-4/main/pull/219[#219],
https://github.com/CS2103-AY1819S1-T12-4/main/pull/233[#233],
https://github.com/CS2103-AY1819S1-T12-4/main/pull/253[#253]
** Enhancements to existing features:
*** Update the Auto-Suggestion window(Pull requests https://github.com/CS2103-AY1819S1-T12-4/main/pull/168[#168])
*** Update ArgumentMultimap to enable hashing the prefix with its relative position(Pull requests https://github.com/CS2103-AY1819S1-T12-4/main/pull/165[#165])
*** Write additional tests for existing features to increase coverage from 79% to 81% (Pull requests https://github.com/CS2103-AY1819S1-T12-4/main/pull/219[#219], https://github.com/CS2103-AY1819S1-T12-4/main/pull/233[#223])
** Documentation:
*** Modify the undo/redo implementation diagram to fit current edition of Developer Guide: (Pull requests https://github.com/CS2103-AY1819S1-T12-4/main/pull/243[#243])
** Community:
*** Review PRs (with non-trivial review comments): https://github.com/CS2103-AY1819S1-T12-4/main/pull/169[#169], https://github.com/CS2103-AY1819S1-T12-4/main/pull/170[#170], https://github.com/CS2103-AY1819S1-T12-4/main/pull/180[#180], https://github.com/CS2103-AY1819S1-T12-4/main/pull/208[#208], https://github.com/CS2103-AY1819S1-T12-4/main/pull/215[#215]
*** Report bugs and suggestions for other teammates in the group (https://github.com/CS2103-AY1819S1-T12-4/main/issues/188[#188], https://github.com/CS2103-AY1819S1-T12-4/main/issues/197[#197] https://github.com/CS2103-AY1819S1-T12-4/main/issues/199[#199], https://github.com/CS2103-AY1819S1-T12-4/main/issues/200[#200], https://github.com/CS2103-AY1819S1-T12-4/main/issues/202[#202], https://github.com/CS2103-AY1819S1-T12-4/main/issues/204[#204], https://github.com/CS2103-AY1819S1-T12-4/main/issues/222[#222], https://github.com/CS2103-AY1819S1-T12-4/main/issues/223[#223])

== Contributions to the User Guide


|===
|_Given below are sections I contributed to the User Guide. They showcase my ability to write documentation targeting end-users._
|===

=== Adding: `(a)add`

Adds an issue to the SaveIt App.

Format: `add i/ISSUE_STATEMENT d/DESCRIPTION [t/TAG]...`

Adds a solution to an existing issue in SaveIt App.

Format: `add s/SOLUTION_LINK r/REMARK`
[TIP]
====
* Select an issue before adding solution
* The solution link validation check only provides most basic format checking
====

Examples: +

****
* `add i/ArrayIndexOutOfBound d/issue description t/unsolved` +
Adds a new issue which has a issue statment called `ArrayIndexOutOfBounds` and issue description called `issue description`

.Add new issue to the issue list
image::AddingNewIssue.png[width="800"]
* `select 3`
* `add s/www.stackoverflow.com r/use functional programming` +
Adds a new solution link which is `www.stackoverflow.com` and a solution remark called `use functional programming`

.Add new solution to the third issue in the issue list
image::AddingNewSolution.png[width="800"]
****

[NOTE]
====
* If multiple identical prefixes are entered, the last prefix value will be accepted
* An issue can have only one statement and description
* An issue can have any number of tags (including 0)
* The index refers to the index number shown in the displayed issue list.
* The index *must be a positive integer* and `1, 2, 3, ...`
* The index cannot be bigger than the number of issues.
* User needs to select the issue index to add a solution to that issue
* The display panel will display the first solution link of the issue at the specified `INDEX`.
* A solution contains one solution link and one remark
* User can add solutions to the same issue continuously
====

=== Retrieving a solution link: `(rv)retrieve`
Retrieves the solution link to the system clipboard

Format: `retrieve INDEX`

[TIP]
====
* Select an issue before retrieving solution link
====

Examples: +
****
* `retrieve 1`
****

[NOTE]
====
* The index refers to the index number on the solution list of a certain issue.
* The index *must be a positive integer* 1, 2, 3, ...
* The index cannot be bigger than the number of solutions of a certain issue.
====

=== Autosuggesting existing issue in find command
To prevent the issue list is so large that user can hardly remember all the issues, whenever user types in any keyword in find command, SaveIt will auto suggest any related issue name according to the keyword entered.

Example:

.Autosuggesting of exsiting issues statements
image::FindIssueAutoSuggestion.png[width="800"]

== Contributions to the Developer Guide

|===
|_Given below are sections I contributed to the Developer Guide. They showcase my ability to write technical documentation and the technical depth of my contributions to the project._
|===

=== Add feature
The add command can add both issue and solution to SaveIt. It includes two levels:

* Issue level
** Issue statement
** Issue description
** Issue tags
* Solution level
** Solution link
** Solution remark

==== Add issue
Add issue happens on the issue level

===== Current implementation
The `SaveItParser` is used to call `AddCommandParser` so as to pass the entered issue. In order to build a new `Issue` object, a dummy solution link and dummy solution remark will be used. After that, `AddCommand` is invoked which will ask model to add the issue to the `Model` component.
In order to store the new issue inside the SaveIt, `VersionedSaveIt` will be invoked and it will add issue to the `UniqueIssueList`.

The following sequence diagram illustrates how the add new issue feature functions:

.Add Issue Command Sequence Diagram
image::AddNewIssue.png[width="800"]

This diagram gives a clear procedure that how the user input is passed step by step and calling different methods and objects at different sequences.

==== Add solution to existing issue
Add solution happens on the solution level

===== Current implementation
The `SaveItParser` is used to call `AddCommandParser` just like how add issue features functions as above mentioned. However, this time, the new solution link and solution remark is provided to `AddCommand` instead. In order to build a new `Issue` object, dummy issue statement and dummy issue description will be used. During execution, `addSolution` method, which was newly added, in Model component will be invoked, to add the solution. The detailed implementation of `addSolution` in model component is quite simple. Since the list stored in application is immutable, each time, a new issue will be created with original statement and description, then the new solution will be added to that particular issue. Finally, `updateIssue` method will be called to replace the issue in `versionedSaveIt`.

The following sequence diagram illustrates how the add solution feature functions

.Add Solution Command Sequence Diagram
image::AddNewSolution.png[width="800"]

This diagram shows the sequence that how add solution command is executed. It could be also noticed that it is basically similar to that of add new issue feature besides it invokes updateIssue method in Model component rather than addIssue method.

==== Design Considerations
===== Aspect: How add solutions executes
* **Alternative 1 (current choice):** Combine AddIssue and AddSolution combined together and distinguishes them at the stage of `AddCommandParser`
** Pros: Consistent syntax between the two features, so the command is more user-friendly.
** Cons: Need to put more effort on distinguishing the difference between these two requests, `AddCommandParser` is relatively complex compared to the other parser component.
* **Alternative 2:** Build a new command especially for adding solution
** Pros: Easy to implement.
** Cons: The command set becomes too complex for the user.

===== Aspect: How add command distinguishes between adding solution and adding issue
* **Alternative 1 (current choice):** Passing a new created issue with dummy issue statement or dummy solution link
** Pros: Consistent coding style and less change on logic structure
** Cons: Quite complex implementation compared to other command
* **Alternative 2:** Overloading Issue constructor so that different issues will be passing to `AddCommand` accordingly.
* Pros: Relatively easier to implement
* Cons: Lots of changes on structure.

=== Retrieve Feature
The retrieve feature allows user to choose a solution link to copy to the system clipboard.

==== Current Implementation

The retrieve feature basically takes the user entered index and call `getFilteredAndSortedList` method in `Model` to get the selected solution. Then Java `Toolkit` package is used to copy the url link of solution to the system clipboard.

=== Suggestion for find command Feature
The suggestion for find command allows user to quickly find the desired issue in SaveIt by showing a drop-down window when related keyword is matched.

==== Current Implementation

The figure below shows a basic relationship between each class.
The `SuggestionLogicManager` implements `SuggestionLogic` interface and overrides the `evaluate` method. Similarly, `IssueNameSuggestion`, `TagNameSuggestion` and `CopyExistingSuggestion` implement `Suggestion` interface and override `evaluate` method.

.SuggestionLogic Class Diagram
image::SuggestionClassUML.png[width="400"]

Since the suggestion component has to retrieve the data from model component to give suggestion according user's entered keywords, it is considered as a part of `Logic` component. By listening to the text field which locates in `CommandBox`, `SuggestionLogicManager` will be able to decide which type of suggestion should be given through parsing the prefix from `ArgumentTokenizer`. Once the `parseFindCommandSuggestion` is triggered, a new `IssueNameSuggestion` class will be created. By calling `getCurrentIssueStatementSet`, `IssueNameSuggestion` is able to match the user input and thus gives the relevant issue statement as a suggestion. The returned `SuggestionResult` will be passed to the `displaySuggestion` method in `CommandBox`. One thing to be noticed, the drop-down window will be hidden once a user input is matched any given suggestion value.

.IssueNameSuggestion Sequence Diagram
image::IssueNameSuggestionDiagram.png[width="800"]

==== Design Consideration
===== Aspect: How to distinguish value of each field and recognize the order of each value
Since the original tokenizer hashes prefix, there is no way to distinguish the order of each value after prefix. For instance, if several prefixes of tag appear, it is impossible to distinguish each tag using tokenizer.

* **Alternative 1 (current choice):** Hash Prefix with its relative distance together

** Pros: Code has a high readability and easy to understand
** Cons: Quite hard to implement as other commands do not require to distinguish the order of each value but suggestion component does. Once hash with prefix and distance, it needs to handle both situation.

* **Alternative 2:** Using subString to get each field from command line input

** Pros: Easy to implement.
** Cons: Bad readability and code quality, no consistency.
